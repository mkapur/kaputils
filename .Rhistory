dir.create(base_temp)
setwd(base_temp)
base_temp <- paste0(rootdir,"/forecasts/forecast", (t-1)+forecast_start)
setwd(rootdir); if(exists(base_temp)) unlink(  paste0(rootdir,"/",base_temp), force = TRUE)
dir.create(base_temp)
setwd(base_temp)
## copy original files into new forecast folder
if(t == 1){
file.copy(from = list.files(
paste0(rootdir,"/",basedir),
full.names = TRUE,
recursive = TRUE),
to = base_temp, overwrite = TRUE)
## change init_src to 1 (read from .par)
strt <- SS_readstarter(file = "starter.ss")
strt$init_values_src <- ifelse(state == 'base',1,0)
strt$last_estimation_phase <- 10 ## could go as high as 20
SS_writestarter(strt, file = "starter.ss", overwrite = TRUE)
## add zeroes to end of par file
mpar <- readLines("ss3.par")
LOI <- grep("Fcast",mpar)+1 ## get line(s) containing data after fcast
NewLine <- strsplit(mpar[LOI],"0 ") ## split elements
length(NewLine[[1]]);length(NewLine[[2]])
for(a in 1:length(NewLine)){
ltemp <- length(NewLine[[a]])
NewLine[[a]][1:ltemp] <- " "
NewLine[[a]][1:(ltemp+(forecast_start-2-replist0$endyr))] <- 0.000000000000 ## ! need to custom this 5
mpar[LOI][a] = paste0(NewLine[[a]], collapse = " ")
}
NewLine <- strsplit(mpar[LOI],"0 ") ## split elements
length(NewLine[[1]]);length(NewLine[[2]])
writeLines(text=mpar, con="ss3.par") ## save it
}
## copy from previous year so as to retain proper catches
if(t>1){
file.copy(list.files(
paste0(rootdir,"/",paste0("forecasts/forecast2021")),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
## now get previous forecast only
file.copy(list.files(
paste0(rootdir,"/",paste0("forecasts/forecast",(forecast_start+t-2))),
full.names = TRUE,
recursive = TRUE)[grep('forecast.ss',list.files(
paste0(rootdir,"/",paste0("forecasts/forecast",(forecast_start+t-2))),
full.names = TRUE,
recursive = TRUE))], to = base_temp, overwrite = TRUE)
}
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecast(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecastMK(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
devtools::install_github("r4ss/r4ss") ## post writeforecast merge
require(r4ss)
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecast(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
t= 2
compname = c('mkapur','Maia Kapur')[2]
rootdir.temp <- rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/blackgill-2019-update/ABC_base")
catch_projections <- read.csv(paste0(rootdir.temp,"/blackgill_proj.csv"))
rootdir = rootdir.temp
state = 'base'
statesex = 2
basedir = "base_2015"
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)]
forecast_start = 2021
forecast_end = 2031
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)]
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020]
replist0 <- SS_output(paste0(rootdir,"/",basedir), covar = F)
base_temp <- paste0(rootdir,"/forecasts/forecast", (t-1)+forecast_start)
setwd(rootdir); if(exists(base_temp)) unlink(  paste0(rootdir,"/",base_temp), force = TRUE)
dir.create(base_temp)
setwd(base_temp)
## copy original files into new forecast folder
if(t == 1){
file.copy(from = list.files(
paste0(rootdir,"/",basedir),
full.names = TRUE,
recursive = TRUE),
to = base_temp, overwrite = TRUE)
## change init_src to 1 (read from .par)
strt <- SS_readstarter(file = "starter.ss")
strt$init_values_src <- ifelse(state == 'base',1,0)
strt$last_estimation_phase <- 10 ## could go as high as 20
SS_writestarter(strt, file = "starter.ss", overwrite = TRUE)
## add zeroes to end of par file
mpar <- readLines("ss3.par")
LOI <- grep("Fcast",mpar)+1 ## get line(s) containing data after fcast
NewLine <- strsplit(mpar[LOI],"0 ") ## split elements
length(NewLine[[1]]);length(NewLine[[2]])
for(a in 1:length(NewLine)){
ltemp <- length(NewLine[[a]])
NewLine[[a]][1:ltemp] <- " "
NewLine[[a]][1:(ltemp+(forecast_start-2-replist0$endyr))] <- 0.000000000000 ## ! need to custom this 5
mpar[LOI][a] = paste0(NewLine[[a]], collapse = " ")
}
NewLine <- strsplit(mpar[LOI],"0 ") ## split elements
length(NewLine[[1]]);length(NewLine[[2]])
writeLines(text=mpar, con="ss3.par") ## save it
}
base_temp
## copy from previous year so as to retain proper catches
if(t>1){
file.copy(list.files(
paste0(rootdir,"/",paste0("forecasts/forecast2021")),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
## now get previous forecast only
file.copy(list.files(
paste0(rootdir,"/",paste0("forecasts/forecast",(forecast_start+t-2))),
full.names = TRUE,
recursive = TRUE)[grep('forecast.ss',list.files(
paste0(rootdir,"/",paste0("forecasts/forecast",(forecast_start+t-2))),
full.names = TRUE,
recursive = TRUE))], to = base_temp, overwrite = TRUE)
}
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecast(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
fore$Nforecastyrs <- forecast_end-replist0$endyr
fore$FirstYear_for_caps_and_allocations <- forecast_start+(t-1)
fore$Ncatch <- replist0$nfishfleets*(t+forecast_start-replist0$endyr-2)
fore$InputBasis <- 2 ## discards
fore$ControlRuleMethod <- 3 ## 3: ramp does catch=f(SSB), buffer on catch
## Fix forecast file to end year selectivity
fore$Bmark_years[1:6] <- 0
fore$Fcast_years[1:4] <- 0
## Fix trawl relative F to reflect proportional catch amounts by fleet in forecast.
fore$fleet_relative_F <- 2 ## will cause original r4ss write_forecast to fail
fore$vals_fleet_relative_f <- paste(paste0(catch_proportions, collapse = " "))
fore$basis_for_fcast_catch_tuning <- 2 ## dead biomass
##  Input correct buffer fraction for this year -- won't matter if CTL rule method == 3
fore$Flimitfraction <- Flimitfraction[t]
## get previous model
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(t-2))), covar = FALSE) ## just load once
## get what that model indicated for the terminal year in question
OFLCatch_thisyear <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
## manually multiply OFL for this year by the buffer
input_forecatch <- OFLCatch_thisyear*Flimitfraction[t-1]
input_forecatch
Flimitfraction
Flimitfraction[t-1]
OFLCatch_thisyear
forecast_start+(t-2)
OFLCatch_thisyear
Flimitfraction
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
tempForeCatch
OFLCatch_thisyear
t = 3
## get previous model
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(t-2))), covar = FALSE) ## just load once
## get what that model indicated for the terminal year in question
OFLCatch_thisyear <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
## manually multiply OFL for this year by the buffer
input_forecatch <- OFLCatch_thisyear*Flimitfraction[t-1]
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
tempForeCatch
OFLCatch_thisyear
t
t = 4
## get previous model
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(t-2))), covar = FALSE) ## just load once
## get what that model indicated for the terminal year in question
OFLCatch_thisyear <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
OFLCatch_thisyear
baseCatch = 1:10
row1Catch = 2:11
row3Catch = 3:13
row3Catch = 3:12
length(baseCatch) != length(row1Catch) != length(row3Catch)
length(baseCatch) != length(years)
years = 2010:2019
length(baseCatch) != length(years)
length(baseCatch)
years = 2010:2020
rootdir <- "C:/Users/Maia Kapur/Downloads/testdc"
dir(rootdir)
state_names = c("low","base","high")
dir(rootdir)[grep(state_names, dir(rootdir))]
dir(rootdir)[grepl(state_names, dir(rootdir))]
dir(rootdir)[grepl(paste0(state_names, collapse =  "|"), dir(rootdir))]
catch_names = c('constant','base','upper')
dir(rootdir)[grepl(paste0(state_names,catch_names, collapse =  "|"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state_names,catch_names), collapse =  "|"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(catch_names,state_names), collapse =  "|"), dir(rootdir))]
catch = 'base'
catch = 'ABC'
state = 'base'
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "|"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "&"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "_"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "&"), dir(rootdir))]
regexpr(catch & state)
dir(rootdir)[grepl(grepl(paste0(state,".*",catch,"|",catch,"*",state), dir(rootdir))]
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
## rename to look nice
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",5))
## save dec_table
if(writeTable == T){
write.csv(dec_table,
file = paste0(writeloc,"/decision_table_",
Sys.Date(),".csv"),
row.names = F)
} ## end if writeTable == T
return(dec_table)
}
dir(rootdir)[grepl(paste0(state,".*",catch,"|",catch,"*",state), dir(rootdir))]
paste0(state,".*",catch,"|",catch,"*",state)
dir(rootdir)[grepl("base.*ABC|ABC*base", dir(rootdir))]
dir(rootdir)[grep("base.*ABC|ABC*base", dir(rootdir))]
grep('ABC',dir(rootdir))
grep('ABC | base',dir(rootdir))
grep('ABC|base',dir(rootdir))
dir(rootdir)[grep("base.*ABC|ABC.*base", dir(rootdir))]
dir(rootdir)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
require(r4ss)
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
tempdir
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
years = 2015:2025
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
tempdir
state
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
tempdir
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
state
state_names
dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state])
grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir)
)
catch_names = c('constant','ABC','upper')
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table
row1Catch
round(row1Catch,2)
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 1 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 3 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 1 &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table
ound(row1Catch,2)
round(row1Catch,2)
## error trapping
if(length(baseCatch) != length(years) | length(row1Catch) != length(years)   |length(row3Catch) != length(years)) {
stop("length of input catch vectors must match length of input years \n")
}
head(dec_table)
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1 ## setup row and column indices
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
mod <- SS_output(tempdir, covar = F); rm(tempdir)
if(catch == 1 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 3 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 1 &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch_names[catch], length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
setwd("C:/Users/Maia Kapur/Dropbox")
devtools::document('kaputils')
devtools::document('kaputils')
devtools::document('kaputils')
devtools::install_github("hadley/devtools")
devtools::install_github("hadley/devtools")
devtools::install_github("hadley/devtools")
require(devtools)
update.packages('rlang')
devtools::document('kaputils')
require(rlang)
devtools::document('kaputils')
install.pacakges('rlang')
install.packages('rlang')
install.packages("rlang")
library(rlang)
library(devtools)
devtools::install_github("hadley/devtools")
setwd("C:/Users/Maia Kapur/Dropbox")
devtools::document("kaputils")
devtools::load_all("kaputils")
