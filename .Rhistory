input_forecatch <- OFLCatch_thisyear*Flimitfraction[t-1]
input_forecatch
Flimitfraction
Flimitfraction[t-1]
OFLCatch_thisyear
forecast_start+(t-2)
OFLCatch_thisyear
Flimitfraction
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
tempForeCatch
OFLCatch_thisyear
t = 3
## get previous model
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(t-2))), covar = FALSE) ## just load once
## get what that model indicated for the terminal year in question
OFLCatch_thisyear <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
## manually multiply OFL for this year by the buffer
input_forecatch <- OFLCatch_thisyear*Flimitfraction[t-1]
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
tempForeCatch
OFLCatch_thisyear
t
t = 4
## get previous model
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(t-2))), covar = FALSE) ## just load once
## get what that model indicated for the terminal year in question
OFLCatch_thisyear <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
OFLCatch_thisyear
baseCatch = 1:10
row1Catch = 2:11
row3Catch = 3:13
row3Catch = 3:12
length(baseCatch) != length(row1Catch) != length(row3Catch)
length(baseCatch) != length(years)
years = 2010:2019
length(baseCatch) != length(years)
length(baseCatch)
years = 2010:2020
rootdir <- "C:/Users/Maia Kapur/Downloads/testdc"
dir(rootdir)
state_names = c("low","base","high")
dir(rootdir)[grep(state_names, dir(rootdir))]
dir(rootdir)[grepl(state_names, dir(rootdir))]
dir(rootdir)[grepl(paste0(state_names, collapse =  "|"), dir(rootdir))]
catch_names = c('constant','base','upper')
dir(rootdir)[grepl(paste0(state_names,catch_names, collapse =  "|"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state_names,catch_names), collapse =  "|"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(catch_names,state_names), collapse =  "|"), dir(rootdir))]
catch = 'base'
catch = 'ABC'
state = 'base'
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "|"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "&"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "_"), dir(rootdir))]
dir(rootdir)[grepl(paste0(c(state,catch), collapse =  "&"), dir(rootdir))]
regexpr(catch & state)
dir(rootdir)[grepl(grepl(paste0(state,".*",catch,"|",catch,"*",state), dir(rootdir))]
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state)
} else if(catch == 'ABC'){
tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
}
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
## rename to look nice
dec_table$Scenario[dec_table$Scenario == 'constant'] <- c(rep(" ",5),'Constant (2019-2020 Average)',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'ABC'] <- c(rep(" ",5),'40-10 Rule',rep(" ",5))
dec_table$Scenario[dec_table$Scenario == 'upper'] <- c(rep(" ",5),'Upper Stream',rep(" ",5))
## save dec_table
if(writeTable == T){
write.csv(dec_table,
file = paste0(writeloc,"/decision_table_",
Sys.Date(),".csv"),
row.names = F)
} ## end if writeTable == T
return(dec_table)
}
dir(rootdir)[grepl(paste0(state,".*",catch,"|",catch,"*",state), dir(rootdir))]
paste0(state,".*",catch,"|",catch,"*",state)
dir(rootdir)[grepl("base.*ABC|ABC*base", dir(rootdir))]
dir(rootdir)[grep("base.*ABC|ABC*base", dir(rootdir))]
grep('ABC',dir(rootdir))
grep('ABC | base',dir(rootdir))
grep('ABC|base',dir(rootdir))
dir(rootdir)[grep("base.*ABC|ABC.*base", dir(rootdir))]
dir(rootdir)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
require(r4ss)
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
tempdir
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
years = 2015:2025
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(c('low','base','high'),each = 2)))
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state,".*",catch,"|",catch,".*",state), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
tempdir
state
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
tempdir
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
state
state_names
dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state])
grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir)
)
catch_names = c('constant','ABC','upper')
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 'constant' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 'upper' & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 'ABC' &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table
row1Catch
round(row1Catch,2)
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
# if(catch != 'ABC'  | state != 'base'){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
# } else if(catch == 'ABC'){
# tempdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_",catch,"_",state,"/forecasts/forecast2030")
# }
mod <- SS_output(tempdir, covar = F)
if(catch == 1 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 3 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 1 &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
# read.csv(paste0(tempdir,"/tempForeCatch.csv"))
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch, length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
# idxc <- idxc+3; idxr <-
#     df["Depletion",y] <- paste0(round(basemod10$derived_quants[grep(paste0("Bratio_",YOI[y],collapse = "|"), basemod10$derived_quants$Label),"Value"],3)*100,"%")
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table
ound(row1Catch,2)
round(row1Catch,2)
## error trapping
if(length(baseCatch) != length(years) | length(row1Catch) != length(years)   |length(row3Catch) != length(years)) {
stop("length of input catch vectors must match length of input years \n")
}
head(dec_table)
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1 ## setup row and column indices
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
mod <- SS_output(tempdir, covar = F); rm(tempdir)
if(catch == 1 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 3 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 1 &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch_names[catch], length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
setwd("C:/Users/Maia Kapur/Dropbox")
devtools::document('kaputils')
devtools::document('kaputils')
devtools::document('kaputils')
devtools::install_github("hadley/devtools")
devtools::install_github("hadley/devtools")
devtools::install_github("hadley/devtools")
require(devtools)
update.packages('rlang')
devtools::document('kaputils')
require(rlang)
devtools::document('kaputils')
install.pacakges('rlang')
install.packages('rlang')
install.packages("rlang")
library(rlang)
library(devtools)
devtools::install_github("hadley/devtools")
setwd("C:/Users/Maia Kapur/Dropbox")
devtools::document("kaputils")
devtools::load_all("kaputils")
devtools::load_all(".")
setwd("C:/Users/mkapur/Dropbox")
devtools::document('kaputils')
devtools::load_all("kaputils")
devtools::document('kaputils')
devtools::document('kaputils')
devtools::load_all(".")
devtools::load_all(".")
setwd("C:/Users/Maia Kapur/Dropbox")
devtools::document('kaputils')
setwd("C:/Users/mkapur/Dropbox")
devtools::document('kaputils')
devtools::document('kaputils')
devtools::load_all("kaputils")
#' compareNA
#' @param v1 first thing, can be NA
#' @param v2 second thing, can be NA
#' @seealso \link["http://www.cookbook-r.com/Manipulating_data/Comparing_vectors_or_factors_with_NA/"]
#' @export
compareNA <- function(v1,v2){
same <- (v1 == v2) | (is.na(v1) & is.na(v2))
same[is.na(same)] <- FALSE
return(same)
}
compareNA
?r4ss::SS_RunJitter()
devtools::load_all(".")
rootdir = rd <- "C:/Users/mkapur/Dropbox/UW/assessments/widow_2019_update/decision_table/fromKC/" ## a directory with all 9 model runs
state_names = c("Low","Base","High")
catch_names = c('constantC','0.45','0.25')
baseCatch = rep("10000", length(2019:2030))
row1Catch =  rep("FILL IN", length(2019:2030))
row3Catch =  rep("FILL IN", length(2019:2030))  round = F
round = F
## error trapping
if(length(baseCatch) != length(years) | length(row1Catch) != length(years)   |length(row3Catch) != length(years)) {
stop("length of input catch vectors must match length of input years \n")
}
years = 2019:2030
## error trapping
if(length(baseCatch) != length(years) | length(row1Catch) != length(years)   |length(row3Catch) != length(years)) {
stop("length of input catch vectors must match length of input years \n")
}
row3Catch =  rep("FILL IN", length(2019:2030))
## error trapping
if(length(baseCatch) != length(years) | length(row1Catch) != length(years)   |length(row3Catch) != length(years)) {
stop("length of input catch vectors must match length of input years \n")
}
if(length(dir(rootdir)) < 9) {
stop("there are less than 9 directories in your root directory, not enough to fill table \n")
}
YOI <- years
dec_table <- matrix(NA, nrow = length(YOI)*3, ncol = 9)
dec_table <- data.frame(dec_table)
names(dec_table) <- c('Scenario','Year','catch',paste(c("spawnbio","depl"),rep(state_names,each = 2)))
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1 ## setup row and column indices
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
mod <- SS_output(tempdir, covar = F); rm(tempdir)
if(catch == 1 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 3 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 1 &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch_names[catch], length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
require(r4ss)
if(round  == T){
dec_table[,c(5,7,9)] <- round(dec_table[,c(5,7,9)],2)
dec_table[,c(4,6,8)] <- round(dec_table[,c(4,6,8)],0)
}
idxr <- idxc <- 1 ## setup row and column indices
for(catch in seq_along(catch_names)){ ## loop catch scen
idxc <- 1 ## reset to initial column for new catch scenario
for(state in seq_along(state_names)){
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
mod <- SS_output(tempdir, covar = F); rm(tempdir)
if(catch == 1 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row1Catch,2)
} else if(catch == 3 & idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(row3Catch,2)
} else if (catch == 1 &  idxc ==2){
dec_table$catch[idxr:(idxr+length(YOI)-1)] <- round(baseCatch,2)
}
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch_names[catch], length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+3] <-  mod$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
idxc <- idxc+1 ## move to next set of columns as state updates
} ## end state
idxr <- idxr+length(YOI) ## jump down to next set of years when catch scenario updates
} ## end catch
dec_table$Year <- rep(YOI,3)
idxr <- idxc <- 1 ## setup row and column indices
catch
idxc <- 1 ## reset to initial column for new catch scenario
state
tempdir <- dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
mod <- SS_output(tempdir, covar = F); rm(tempdir)
catch == 1 & idxc ==2
catch == 3 & idxc ==2
catch == 1 &  idxc ==2
## input what was given to forecast file
dec_table$Scenario[idxr:(idxr+length(YOI)-1)] <- rep(catch_names[catch], length(idxr:(idxr+length(YOI)-1)))
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2] <-  mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
dec_table[idxr:(idxr+length(YOI)-1),idxc*2+2]
mod$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"),
mod$derived_quants$Label),"Value"]
YOI
mod$derived_quants[grep("SSB_",
mod$derived_quants$Label),"Value"]
mod$derived_quants[grep("SSB_",
mod$derived_quants$Label),]
devtools::load_all(".")
rootdir = "C:/Users/mkapur/Dropbox/UW/assessments/widow_2019_update/decision_table/mk_attempts2"
state_names = c("low","base","high"),
years = 2021:2030,
catch_names = c('contsC','p045','p025'),
baseCatch = bc45[,1],
row1Catch =  concstc[,1],
row3Catch =  bc25[,1],
round = F,
writeTable = F,
writeloc = rd
state_names = c("low","base","high")
years = 2021:2030,
catch_names = c('contsC','p045','p025');
baseCatch = bc45[,1];
row1Catch =  concstc[,1];
row3Catch =  bc25[,1];
round = F;
writeTable = F;
writeloc = rd
dir(rootdir, full.names = T)
dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
state_names
state = 'low'
state = 1
catch = 1
dir(rootdir, full.names = T)[grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))]
grepl(paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state]), dir(rootdir))
paste0(state_names[state],".*",catch_names[catch],"|",catch_names[catch],".*",state_names[state])
