writeLines(text=mpar, con="ss3.par") ## save it
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecast(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
fore$Nforecastyrs <- forecast_end-replist0$endyr
fore$FirstYear_for_caps_and_allocations <- forecast_start+(t-1)
fore$Ncatch <- replist0$nfishfleets*(t+forecast_start-replist0$endyr-2)
fore$ControlRuleMethod <- 3 ## 3: ramp does catch=f(SSB), buffer on catch
fore$InputBasis <- 2 ## discards
inityr <- max(fore$ForeCatch$Year)
if(inityr == Inf   | inityr == -Inf) inityr <- catch_projections$YEAR[1]-1 ## overwrite if INF
if(class( fore$ForeCatch) =='NULL')  fore$ForeCatch <- data.frame('Year' = NA, 'Seas' = NA,'Fleet' = NA, 'Catch_or_F' =NA)
fore$ForeCatch <- data.frame('Year' = NA, 'Seas' = NA,'Fleet' = NA, 'Catch_or_F' =NA) ## overwrite entire forecatch
for(k in 1:(forecast_start-1-inityr)){
# term <- nrow(fore$ForeCatch) ## intital final row
# if(class(term) =='NULL') term <- 0
term <- 0
for(i in 1:replist0$nfishfleets){
fore$ForeCatch[term+i,'Year'] <- inityr+k
fore$ForeCatch[term+i,'Seas'] <- 1
fore$ForeCatch[term+i,'Fleet'] <- i
fore$ForeCatch[term+i,'Catch_or_F'] <- fixed_catches[k,i]
} ## end nfleets
} ## end yrs to 2020
fore$ForeCatch
inityr
k
forecast_start-1-inityr
1:(forecast_start-1-inityr)
fore$ForeCatch <- data.frame('Year' = NA, 'Seas' = NA,'Fleet' = NA, 'Catch_or_F' =NA) ## overwrite entire forecatch
for(k in 1:(forecast_start-1-inityr)){
# term <- nrow(fore$ForeCatch) ## intital final row
# if(class(term) =='NULL') term <- 0
term <- 0
for(i in 1:replist0$nfishfleets){
fore$ForeCatch[term+i,'Year'] <- inityr+k
fore$ForeCatch[term+i,'Seas'] <- 1
fore$ForeCatch[term+i,'Fleet'] <- i
fore$ForeCatch[term+i,'Catch_or_F'] <- fixed_catches[k,i]
} ## end nfleets
} ## end yrs to 2020
fore$ForeCatch
# term <- nrow(fore$ForeCatch) ## intital final row
# if(class(term) =='NULL') term <- 0
term <- 0
k = 1
for(i in 1:replist0$nfishfleets){
fore$ForeCatch[term+i,'Year'] <- inityr+k
fore$ForeCatch[term+i,'Seas'] <- 1
fore$ForeCatch[term+i,'Fleet'] <- i
fore$ForeCatch[term+i,'Catch_or_F'] <- fixed_catches[k,i]
} ## end nfleets
fore$ForeCatch
fore$ForeCatch <- data.frame('Year' = NA, 'Seas' = NA,'Fleet' = NA, 'Catch_or_F' =NA) ## overwrite entire forecatch
for(k in 1:(forecast_start-1-inityr)){
# if(class(term) =='NULL') term <- 0
term <-  ifelse(k == 1, 0, nrow(fore$ForeCatch) ) ## start from zero first time
for(i in 1:replist0$nfishfleets){
fore$ForeCatch[term+i,'Year'] <- inityr+k
fore$ForeCatch[term+i,'Seas'] <- 1
fore$ForeCatch[term+i,'Fleet'] <- i
fore$ForeCatch[term+i,'Catch_or_F'] <- fixed_catches[k,i]
} ## end nfleets
} ## end yrs to 2020
fore$ForeCatch
catch_projections
fixed_catches
k
forecast_start
inityr
replist0$endyr
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecast(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
fore$Nforecastyrs <- forecast_end-replist0$endyr
fore$FirstYear_for_caps_and_allocations <- forecast_start+(t-1)
fore$Ncatch <- replist0$nfishfleets*(t+forecast_start-replist0$endyr-2)
fore$InputBasis <- 2 ## discards
fore$ControlRuleMethod <- 3 ## 3: ramp does catch=f(SSB), buffer on catch
# inityr <- max(fore$ForeCatch$Year)
inityr <- replist0$endyr
if(inityr == Inf   | inityr == -Inf) inityr <- catch_projections$YEAR[1]-1 ## overwrite if INF
fore$ForeCatch <- data.frame('Year' = NA, 'Seas' = NA,'Fleet' = NA, 'Catch_or_F' =NA) ## overwrite entire forecatch
for(k in 1:(forecast_start-1-inityr)){
# if(class(term) =='NULL') term <- 0
term <-  ifelse(k == 1, 0, nrow(fore$ForeCatch) ) ## start from zero first time
for(i in 1:replist0$nfishfleets){
fore$ForeCatch[term+i,'Year'] <- inityr+k
fore$ForeCatch[term+i,'Seas'] <- 1
fore$ForeCatch[term+i,'Fleet'] <- i
fore$ForeCatch[term+i,'Catch_or_F'] <- fixed_catches[k,i]
} ## end nfleets
} ## end yrs to 2020
fore$ForeCatch
## Fix forecast file to end year selectivity
fore$Bmark_years[1:6] <- 0
fore$Fcast_years[1:4] <- 0
## Fix trawl relative F to reflect proportional catch amounts by fleet in forecast.
fore$fleet_relative_F <- 2 ## will cause original r4ss write_forecast to fail
fore$vals_fleet_relative_f <- paste(paste0(catch_proportions, collapse = " "))
fore$basis_for_fcast_catch_tuning <- 2 ## dead biomass
##  Input correct buffer fraction for this year -- won't matter if CTL rule method == 3
fore$Flimitfraction <- Flimitfraction[t]
# Step 5b. Iterate the forecast file -- only if
fore$Nforecastyrs <- forecast_end-replist0$endyr
fore$FirstYear_for_caps_and_allocations <- forecast_start+(t-1)
fore$Ncatch <- replist0$nfishfleets*(t+forecast_start-replist0$endyr-2)
fore$InputBasis <- 2 ## discards
fore$ControlRuleMethod <- 3 ## 3: ramp does ca
t = 2
# tempForeCatch <- SS_ForeCatch(mod1,
#                               yrs = 2021:(2021+(t-2)), ## just do THIS year
#                               average = FALSE,
#                               total = predOFLs_startForecast)
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
devtools::load_all("C:/Users/mkapur/Dropbox/kaputils")
state = 'base'
r = 'North'
devtools::load_all("C:/Users/mkapur/Dropbox/kaputils")
rootdir.temp <- rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_low")
catch_projections <- read.csv(paste0(rootdir.temp,"/cproj_North.csv"))
rootdir = rootdir.temp
state = 'low'
statesex = 2
basedir = "base2015"
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)]
forecast_start = 2021
forecast_end = 2031
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)]
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020]
state != 'base'
base_temp <- rootdir
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('.ctl', list.files(base_temp))])
statesex
statesex = 1
statesex == 0  | statesex == 1
if(statesex == 0  | statesex == 1){
term <- terms[stateSex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
mctl <- readLines(list.files(base_temp)[grep('.ctl', list.files(base_temp))])
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
cr.statevals <- data.frame(matrix(NA, ncol = 3, nrow = 1))
colnames(cr.statevals) <- c('low','base','high')
row.names(cr.statevals) <- c('Fem')
cr.statevals$low <- c(0.05)
cr.statevals$base <- c(0.07)
cr.statevals$high <- c(0.09)]
cr.statevals <- data.frame(matrix(NA, ncol = 3, nrow = 1))
colnames(cr.statevals) <- c('low','base','high')
row.names(cr.statevals) <- c('Fem')
cr.statevals$low <- c(0.05)
cr.statevals$base <- c(0.07)
cr.statevals$high <- c(0.09)
statevals = cr.statevals
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
term <- terms[statesex+1]
term
statesex
statesex = 0
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
term <- terms[statesex+1]
term
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
mctl[LOI][1]
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
statevals
devtools::load_all("C:/Users/mkapur/Dropbox/kaputils")
state
state = 'high'
statevals[t,state] ##
statevals
statevals
statevals$state
statevals[1,state]
t
statesex
statevals[1,state] #
mctl
paste(list.files(base_temp)[grep('_control', list.files(base_temp))])
base_temp
rootdir.temp <- rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/")
state = 'high'
base_temp <- rootdir
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
base_temp
rootdir.temp <- rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_high")
base_temp <- rootdir
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
base_temp <- rootdir
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
rm(list = ls())
cr.statevals <- data.frame(matrix(NA, ncol = 3, nrow = 1))
colnames(cr.statevals) <- c('low','base','high')
row.names(cr.statevals) <- c('Fem')
cr.statevals$low <- c(0.05)
cr.statevals$base <- c(0.07)
cr.statevals$high <- c(0.09)
statevals <- cr.statevals
rootdir.temp <- rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_high")
catch_projections <- read.csv(paste0(rootdir.temp,"/cproj_North.csv"))
rootdir = rootdir.temp
state = 'high'
statesex = 1
basedir = "base2015"
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)]
forecast_start = 2021
forecast_end = 2031
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)]
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020]
compname = c('mkapur','Maia Kapur')[1]
cr.statevals <- data.frame(matrix(NA, ncol = 3, nrow = 1))
colnames(cr.statevals) <- c('low','base','high')
row.names(cr.statevals) <- c('Fem')
cr.statevals$low <- c(0.05)
cr.statevals$base <- c(0.07)
cr.statevals$high <- c(0.09)
statevals <- cr.statevals
rootdir.temp <- rootdir <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_high")
catch_projections <- read.csv(paste0(rootdir.temp,"/cproj_North.csv"))
rootdir = rootdir.temp
state = 'high'
statesex = 1
basedir = "base2015"
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)]
forecast_start = 2021
forecast_end = 2031
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)]
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020]
catch_projections <- read.csv(paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/crNorth_ABC_base/cproj_North.csv"))
rootdir = rootdir.temp
state = 'high'
statesex = 1
basedir = "base2015"
catch_proportions = catch_projections[catch_projections$YEAR == 2021,5:ncol(catch_projections)]
forecast_start = 2021
forecast_end = 2031
fixed_catches = catch_projections[catch_projections$YEAR < 2021,5:ncol(catch_projections)]
Flimitfraction = catch_projections$PSTAR_0.45[catch_projections$YEAR >2020]
state
base_temp <- rootdir
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
base_temp
r =
'North'
base_temp <- rootdir
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
statesex
statesex= 0
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
rootdir
paste0(rootdir,"/bg_ABC_",state)
rootdir = paste0("C:/Users/",compname,"/Dropbox/UW/assessments/blackgill-2019-update/")
base_temp <- paste0(rootdir,"/bg_ABC_",state)
base_temp
state = 'low'
base_temp <- paste0(rootdir,"/bg_ABC_",state)
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
paste0(dirname(rootdir),"bg_ABC_base/forecasts/forecast2030")
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030")
file.copy(list.files(
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
file.copy(list.files(
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
base_temp
base_temp <- paste0(rootdir,"bg_ABC_",state)
base_temp
file.copy(list.files(
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030")
list.files(
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE)
rootdir
paste0(dirname(rootdir),"/bg_ABC_base/forecasts/forecast2030")
file.copy(list.files(
paste0(rootdir,"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
state = 'high'
base_temp <- paste0(rootdir,"bg_ABC_",state)
base_temp
file.copy(list.files(
paste0(rootdir,"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
## change init_src to 0 (read from .par)
strt <- SS_readstarter(file = "starter.ss")
strt$init_values_src <- ifelse(state == 'base',1,0)
SS_writestarter(strt, file = "starter.ss", overwrite = TRUE)
system('ss3 -nohess')
statesex
statesex = 2
base_temp <- paste0(rootdir,"bg_ABC_",state)
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(rootdir,"/bg_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
setwd(base_temp)
terms <- c("NatM_p_1_Fem_GP_1","NatM_p_1_Mal_GP_1")
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
if(statesex == 0  | statesex == 1){
term <- terms[statesex+1]
LOI <- grep(term,mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <-  statevals[1,state] ## there will only be 1 row if 1 sex is specified
# NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
} else if(statesex == 2){ ## do both sequentially
for(t in 1:length(terms)){
LOI <- grep(terms[t],mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI], "\\s+")[[1]] ## split elements by any amt of whitespace
NewLine[3] <-  statevals[t,state] ## select by sex and state
mctl[LOI] <- paste0(NewLine, collapse = "\t")
} ## end loop t over sexes
} ## end if stateSex == 2
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
min(catch_projections$YEAR)
catch_projections$YEAR[1]
min(catch_projections$YEAR)
devtools::load_all("C:/Users/mkapur/Dropbox/kaputils")
