LOI <- grep("Fcast",mpar)+1 ## get line(s) containing data after fcast
NewLine <- strsplit(mpar[LOI],"0 ") ## split elements
length(NewLine[[1]]);length(NewLine[[2]])
for(a in 1:length(NewLine)){
ltemp <- length(NewLine[[a]])
NewLine[[a]][1:ltemp] <- " "
NewLine[[a]][1:(ltemp+(forecast_start-2-replist0$endyr))] <- 0.000000000000 ## ! need to custom this 5
mpar[LOI][a] = paste0(NewLine[[a]], collapse = " ")
}
NewLine <- strsplit(mpar[LOI],"0 ") ## split elements
length(NewLine[[1]]);length(NewLine[[2]])
writeLines(text=mpar, con="ss3.par") ## save it
}
# list.files(
#   paste0(rootdir,"/",base_temp),
#   full.names = TRUE,
#   recursive = TRUE), overwrite = TRUE)
## copy from previous year so as to retain proper catches
if(t>1){
file.copy(list.files(
paste0(rootdir,"/",paste0("forecasts/forecast2021")),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
## now get previous forecast only
file.copy(list.files(
paste0(rootdir,"/",paste0("forecasts/forecast",(forecast_start+t-2))),
full.names = TRUE,
recursive = TRUE)[grep('forecast.ss',list.files(
paste0(rootdir,"/",paste0("forecasts/forecast",(forecast_start+t-2))),
full.names = TRUE,
recursive = TRUE))], to = base_temp, overwrite = TRUE)
}
## Step 4a. Add catch/projections through given year. -- this will likely need to revert to MK version to 'build on' prev
fore <- SS_readforecastMK(file = './forecast.ss',
Nareas = replist0$nareas,
Nfleets = replist0$nfishfleets,
nseas = 1,
version = paste(replist0$SS_versionNumeric),
readAll = TRUE)
# fore <-  SS_readforecast(file = './forecast.ss',
#                          Nareas = replist0$nareas,
#                          Nfleets = replist0$nfishfleets,
#                          nseas = replist0$nseasons,
#                          version = paste(replist0$SS_versionNumeric),
#                          readAll = TRUE)
fore$Nforecastyrs <- forecast_end-replist0$endyr
fore$FirstYear_for_caps_and_allocations <- forecast_start+(t-1)
fore$Ncatch <- replist0$nfishfleets*(t+forecast_start-replist0$endyr-2)
fore$InputBasis <- 2 ## discards
fore$ControlRuleMethod <- 3 ## 3: ramp does catch=f(SSB), buffer on catch
## Now Add Catch data/projections thru the year before forecast_start.
## This acts similarly to SS_ForeCatch except it reads directly from your inputs.
if(t == 1){
inityr <- max(fore$ForeCatch$Year)
for(k in 1:(forecast_start-1-inityr)){
term <- nrow(fore$ForeCatch) ## intital final row
for(i in 1:replist0$nfishfleets){
fore$ForeCatch[term+i,'Year'] <- inityr+k
fore$ForeCatch[term+i,'Seas'] <- 1
fore$ForeCatch[term+i,'Fleet'] <- i
fore$ForeCatch[term+i,'Catch_or_F'] <- fixed_catches[k,i]
} ## end nfleets
} ## end yrs to 2020
}
## Fix forecast file to end year selectivity
fore$Bmark_years[1:6] <- 0
fore$Fcast_years[1:4] <- 0
## Fix trawl relative F to reflect proportional catch amounts by fleet in forecast.
fore$fleet_relative_F <- 2 ## will cause original r4ss write_forecast to fail
fore$vals_fleet_relative_f <- paste(paste0(catch_proportions, collapse = " "))
fore$basis_for_fcast_catch_tuning <- 2 ## dead biomass
##  Input correct buffer fraction for this year -- won't matter if CTL rule method == 3
fore$Flimitfraction <- Flimitfraction[t]
# Step 5b. Iterate the forecast file -- only if not first iter
## Find the total forecasted catch for specific years in the "mod1" object generated by SS_output below.
## Allocate this catch among the fleets according to the given proportions
## add this to forecast file in increments
if(t > 1){ ## add a single year of catch
# if(t == 2)
## get previous model
mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast",(forecast_start+(t-2))), covar = FALSE) ## just load once
## get what that model indicated for the terminal year in question
OFLCatch_thisyear <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
## manually multiply OFL for this year by the buffer
input_forecatch <- OFLCatch_thisyear*Flimitfraction[t-1]
# modX <- SS_output(paste0(rootdir,"/forecasts/forecast",forecast_start+(t-1)), covar = FALSE) ## just load once
# predOFLs_startForecast <-  mod_prev$derived_quants[grep(paste0("OFLCatch_",(forecast_start+(t-2)),collapse = "|"), mod_prev$derived_quants$Label),"Value"]
# tempForeCatch <- SS_ForeCatch(mod1,
#                               yrs = 2021:(2021+(t-2)), ## just do THIS year
#                               average = FALSE,
#                               total = predOFLs_startForecast)
tempForeCatch <- SS_ForeCatch(mod_prev,
yrs = forecast_start+(t-2), ## just do THIS year
average = FALSE,
total = input_forecatch)
# total = df$PredOFL[df$Year %in% (forecast_start+(t-2))]) ## total are the total catches for each year, given by OFLcatch
fore$ForeCatch[(nrow(fore$ForeCatch)+1):(nrow(fore$ForeCatch)+nrow(tempForeCatch)),] <- tempForeCatch[,1:4]
if(t == 10){
## fill in last row even though not used
writecatch <- fore$ForeCatch %>% filter(Year > 2020) %>% group_by(Year) %>% dplyr::summarise(Catch_Used = sum(Catch_or_F))
idx = nrow(writecatch)
# mod_prev <- SS_output(paste0(rootdir,"/forecasts/forecast2029"), covar = FALSE) ## find what
# mod prev should still be 2029 (vals thru 2028); find what it says about 2030
OFLCatch_thisyear <-  mod_prev$derived_quants[grep("OFLCatch_2030", mod_prev$derived_quants$Label),"Value"] #
writecatch[idx+1,'Year'] <- 2030
writecatch[idx+1,'Catch_Used'] <- OFLCatch_thisyear*Flimitfraction[10]
rm(idx)
write.csv(writecatch,
file = "./tempForeCatch.csv",row.names = FALSE) ## save final year ABC catch
}
} ## end forecast if t > 1
cat(paste0('Added forecast catch thru year ',forecast_start+(t-2),"\n"))
## save file
SS_writeforecastMK(fore, file = './forecast.ss', overwrite = TRUE)
## execute model
## manual overwrite fleetrelF
# if(t < foreyrs){
system('ss3 -nohess') ## works
# } else if(t==foreyrs){
# system('ss3') ## run w hessian last time
# }
# if(t == 10){
#
#   mod10 <- SS_output(paste0(rootdir,"/forecasts/forecast",forecast_end-1), covar = FALSE)
#   YOI <- (replist0$endyr+1):(forecast_end); lYOI <- length(YOI)
#   ## this will read the output of the first model and save the OFLs
#   ## which will get used to comptue subsequent mods
#   ## https://github.com/melmonk/StockAssessment_template/blob/master/8a_Tables.Rmd
#   df[1:lYOI,"Year"] <- YOI
#   df[1:lYOI,"PredOFL"] <-  mod10$derived_quants[grep(paste0("OFLCatch_",YOI,collapse = "|"), mod10$derived_quants$Label),"Value"]
#   df[1:lYOI,"ForeCatch_ABC"] <- mod10$derived_quants[grep(paste0("ForeCatch_",YOI,collapse = "|"), mod10$derived_quants$Label),"Value"]
#   endyrABC <- read.csv(paste0(rootdir,'/forecasts/forecast',forecast_end-1,"/tempForeCatch.csv")) ## the ABC which was used
#   # df[1:lYOI,"ABC"] <-   endyrABC %>% filter(X.Year %in% YOI) %>% group_by(X.Year) %>% summarise(sumCatch = sum(dead.B.))
#   ForecastC.dead = mod10$timeseries[, grepl('Yr|dead[(]B', names(mod10$timeseries))]
#   ForecastC.dead$total = rowSums(ForecastC.dead[, -1])
#   # ForecastC.ret = mod10$timeseries[, grepl('Yr|retain[(]B', names(mod10$timeseries))]
#   # ForecastC.ret$total = rowSums(ForecastC.dead[, -1])
#   df[1:lYOI,"ForecastC.dead"] <- subset(ForecastC.dead, Yr %in% YOI)$total ## should equal ForeCatch ABC
#   # df[1:lYOI,"ForecastC.ret"] <- subset(ForecastC.ret, Yr %in% YOI)$total
#   # df[1:lYOI,"ForecastC.dead+ret"] <- rowSums(cbind(df$ForecastC.dead,df$ForecastC.ret))
#   df[1:lYOI,"Age10+Biomass"] <- subset(mod10$timeseries[, c('Yr', 'Bio_smry')], Yr %in% YOI)$Bio_smry
#   df[1:lYOI,"SpawnBio"] <-mod10$derived_quants[grep(paste0("SSB_",YOI,collapse = "|"), mod10$derived_quants$Label),"Value"]
#   df[1:lYOI,"Depletion"] <- paste0(round(mod10$derived_quants[grep(paste0("Bratio_",YOI,collapse = "|"), mod10$derived_quants$Label),"Value"],3)*100,"%")
#   for(i in YOI){ ## grab ovserved and/or forecast catch for all fleets f
#     df$FiveYrAvgCatch[df$Year == i] <- mean(c(mod10$catch$Obs[mod10$catch$Yr %in% c(i:(i-5))],
#                                               mod10$derived_quants[grep(paste0("ForeCatch_",i:(i-5),collapse = "|"), mod10$derived_quants$Label),"Value"]))
#   } ## end 5yr avg
#   df$PredOFL[df$Year < forecast_start] <- df$ForeCatch_ABC[df$Year < forecast_start]<- NA
#   df[,2:4] <- round(df[,2:4],2)
#   write.csv(df,file =paste0(rootdir,"/forecasts/decision_table_base.csv"),row.names = FALSE)
# }
# cat(paste0('Executed model with forecast thru year ',forecast_start+(t-1),"\n"))
# Step 5c. Iterate through 2030 -- the loop will continue making a new folder each time
} ## end t loop
} ## end if state == base
warnings()
state = 'high'
rootdir
## copy from base 2030; everything should be updated
base_temp <- rootdir
rootdir.temp <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_",state)
r = 'Central'
rootdir =    rootdir.temp <- paste0("C:/Users/",compname,"/Dropbox/UW/assessments/china_2019_update/chinarock-update-2019/cr",r,"_ABC_",state)
## copy from base 2030; everything should be updated
base_temp <- rootdir
base_temp
if(!exists(base_temp)) dir.create(base_temp)
file.copy(list.files(
paste0(dirname(rootdir),"/cr",r,"_ABC_base/forecasts/forecast2030"),
full.names = TRUE,
recursive = TRUE), to = base_temp, overwrite = TRUE)
## update CTL file with state of nature low/base/high (all fixed, reading from par)
setwd(base_temp)
mctl <- readLines(list.files(base_temp)[grep('_control', list.files(base_temp))])
LOI <- grep("NatM_p_1_Fem_GP_1",mctl)[1] ## get line(s) containing data after natm, ignoring comment
NewLine <- strsplit(mctl[LOI],"   ") ## split elements
NewLine[[1]][3] <- ifelse(state == 'low', 0.05, ifelse(state == 'high', 0.09, 0.07))
mctl[LOI][1] = paste0(NewLine[[1]], collapse = " ")
writeLines(text=mctl, con= paste(list.files(base_temp)[grep('_control', list.files(base_temp))])) ## save it
## change init_src to 0 (read from .par)
strt <- SS_readstarter(file = "starter.ss")
strt$init_values_src <- ifelse(state == 'base',1,0)
SS_writestarter(strt, file = "starter.ss", overwrite = TRUE)
system('ss3 -nohess')
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
nboot = 50
simu_year = 100
burn_yr = 20
Inst_M = 0.2
L1 = 10
a1 = 1
L2 = 100
a2 = 15
growth_lognormal_SD = 0.015
steepBH = 0.9
R0 = 10
## some presets ----
## Beverton-Holt SRR
sigma_R = 0.1
# B-H S-R FUNCTION
BH_SR = function(SSBy){
y = (4*steepBH*R0*SSBy/(SSB0*(1-steepBH)+SSBy*(5*steepBH-1)))
y
}
## Generate Equilibrium Population ----
Neqn <- rep(0,a2)
S <- exp(-Inst_M)
Neqn[1] <- R0 ## AEP set to 100
for (Iage in 2:a2) Neqn[Iage] <- Neqn[Iage-1]*S ## survivorship
Neqn[a2] <- Neqn[a2]/(1-S) ## plus group
# Length-at-age
init_length = NULL
error = exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2)
init_length[1] = L1*error
Linf = L1+(L2-L1)/(1-exp(-VBGF_K*(a2-a1)))
## Growth increment FUNCTION, NON TV: FROM V7
growth_incre  <- function(fish_size){
y=(Linf-fish_size)*(1-exp(-VBGF_K))
y
}
# Length-at-age
init_length = NULL
error = exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2)
init_length[1] = L1*error
for(g in 1:(a2)){
init_length[g+1] = init_length[g]+growth_incre(init_length[g])*error
}
init_length <- init_length[1:a2]
# Weight-at-age
init_weight = lw(init_length)
# Maturity-at-age
init_mat = round(prob_mature(init_length) ,1)
SSB0 <- sum(Neqn*init_mat*init_weight) ## What
Linf = L1+(L2-L1)/(1-exp(-VBGF_K*(a2-a1)))
VBGF_K = 0.25
## some presets ----
## Beverton-Holt SRR
sigma_R = 0.1
## bev holt steepness
# B-H S-R FUNCTION
BH_SR = function(SSBy){
y = (4*steepBH*R0*SSBy/(SSB0*(1-steepBH)+SSBy*(5*steepBH-1)))
y
}
Linf = L1+(L2-L1)/(1-exp(-VBGF_K*(a2-a1)))
## Growth increment FUNCTION, NON TV: FROM V7
growth_incre  <- function(fish_size){
y=(Linf-fish_size)*(1-exp(-VBGF_K))
y
}
## Generate Equilibrium Population ----
Neqn <- rep(0,a2)
S <- exp(-Inst_M)
Neqn[1] <- R0 ## AEP set to 100
for (Iage in 2:a2) Neqn[Iage] <- Neqn[Iage-1]*S ## survivorship
Neqn[a2] <- Neqn[a2]/(1-S) ## plus group
# Length-at-age
init_length = NULL
error = exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2)
init_length[1] = L1*error
for(g in 1:(a2)){
init_length[g+1] = init_length[g]+growth_incre(init_length[g])*error
}
init_length <- init_length[1:a2]
# Weight-at-age
init_weight = lw(init_length)
# Maturity-at-age
init_mat = round(prob_mature(init_length) ,1)
SSB0 <- sum(Neqn*init_mat*init_weight) ##
lw_a
lw_a = 2e-4
lw_b = 3
lw  = function(fish_size){
y=lw_a*fish_size^lw_b
y
}
# Weight-at-age
init_weight = lw(init_length)
# Maturity-at-age
init_mat = round(prob_mature(init_length) ,1)
# Maturity ogive FUNCTION
prob_mature = function(fish_size){
y = 1/(1+exp(r*(fish_size-L50)))
y
}
# Maturity-at-age
init_mat = round(prob_mature(init_length) ,1)
r_mat = 0.1
L50 = 44
# Maturity ogive FUNCTION
prob_mature = function(fish_size){
y = 1/(1+exp(r_mat*(fish_size-L50)))
y
}
# Maturity-at-age
init_mat = round(prob_mature(init_length) ,1)
SSB0 <- sum(Neqn*init_mat*init_weight) ## What we'd expect from a single population
NIBM <- data.frame("Age" = NA, "Length_cm" = NA, "Mature" = NA, "Weight" = NA,
"Year" = NA, 'UniqueID' = NA)
## Populate initial individuals @ age. this number will not change, it is fixed, scaled by R0
Ipnt <- 0
for (Iage in 1:a2){ ## loop possible ages
Nage <- round(Neqn[Iage]) # Integer numbers
for (Inum in 1:Nage){ ## loop lifespan
Ipnt <- Ipnt + 1 ## counting up individuals, new row for each
NIBM[Ipnt,1] <- Iage-1 ## age
# Length (initial)
NIBM[Ipnt,2] <- init_length[Iage]+growth_incre(init_length[Iage])*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2) ## recalc error each time
# Is this animal mature off the bat
NIBM[Ipnt,3] <- runif(1,0,1) < prob_mature(NIBM[Ipnt,2])  ## logistic ogive, coinflip here gives x
# Weight
NIBM[Ipnt,4] <- lw( NIBM[Ipnt,2])
NIBM[Ipnt,5] <- 0
NIBM[Ipnt,6] <- Ipnt
}
}
Ipnt0 <- Ipnt
# Compute the Ps -- this is the conditional probability step, based on raw...expectation?
P <- rep(1,a2); P[1] <- 0
# with(NIBM, plot(Length_cm, Mature))
# Now loop forward [this is where mine comes in]
for(ry in 1:simu_year){ ## iterate sim years
# Alive <- !is.na(NIBM[,'Age']) & NIBM[,'Age'] > -1
# if(sum(is.na(NIBM[Alive,'Mature']))>0) stop(min(which(is.na(NIBM[Alive,'Mature'])))," is NA mature")
# cat("Alive",sum(Alive),"\n")
# Compute SSB
# Compute recruits here, this is how many we need to add later
if(ry == 1){
SSBy[ry] <- SSB0 ## SSB from last yr informs recruits
RECy[ry] <- round(BH_SR(SSB0) * exp(recruit_dev_adj[ry]))
}else{
SSBy[ry] <- sum(NIBM$Mature[NIBM$Year == (ry-1)] * NIBM$Weight[NIBM$Year == (ry-1)]) ## Mature of living x weight of living [survived]
RECy[ry] <- round(BH_SR(SSBy[ry]) * exp(recruit_dev_adj[ry]))
}
if(SSBy == 0)stop(ry," SSBY = 0 \n")
if(RECy[ry] < 1){ ## fail if less than one recruit
RECy[ry]=1 ## coerce to 1
print(paste0("!!! Recruitment Fail !!! year ",ry))
}
Ilast <- ifelse(ry == 1,1,min(which(NIBM$Year == (ry-1))))  ## where do individuals for prev year begin?
Ipnt <- ifelse(ry == 1,Ipnt0, nrow(subset(NIBM, Year == (ry-1)))) ## number of individuals
idx <- nrow(NIBM) ## last filled in row
for (II in Ilast:(Ilast+Ipnt-1)){ ## loop individuals for this year [given by Ipnt]
# if (Alive[II]){
MyAge <- NIBM[II,1] ## check age
# cat(NIBM[II,'UniqueID'],"\n") ## should not duplicate
NIBM[idx+1,'UniqueID'] <- NIBM[II,'UniqueID'] ## retain ID
NIBM[idx+1,'Year'] <- ry ## update year
# Died this year?
NIBM[idx+1,'Age'] <- ifelse(runif(1,0,1) > S, -1, ifelse(NIBM[II,'Age']+1 <= 15,NIBM[II,'Age']+1,15 )) ## Update dead, if not increase age by 1 year, coerce to 15 if older
# Now grow the animal and update its weight
NIBM[idx + 1, 'Length_cm'] <- NIBM[II, 'Length_cm'] +growth_incre(NIBM[II, 'Length_cm'])*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2)
NIBM[idx + 1, 'Weight'] <-  lw( NIBM[II,'Length_cm'])
# Mature this year?
if (is.na(NIBM[II,'Mature'])){NIBM[II,'Mature'] <- 0} ## replace NAs
if (NIBM[II,'Mature'] == 1){NIBM[idx + 1,'Mature'] <- 1} ## cannot un-mature
if(MyAge < 15 & NIBM[II,'Mature'] == 0){
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1) < P[MyAge+1],1,0)
} else if(MyAge >= 15 & NIBM[II,'Mature'] == 0){
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1) < P[MyAge],1,0)
}
idx <- idx + 1 ## bump down a row
# Add recruits starting from slots Ipnt + 1
# Ipnt <- Ipnt + 1 ## counting up individuals, new row for each
# } ## end if living
} ## end individuals
for(ir in 1:RECy[ry]){ ## now add individuals
NIBM[idx + 1,'UniqueID'] <- max(NIBM$UniqueID) + 1 ## new id; DO FIRST OTHERWISE FILLS NA
NIBM[idx + 1,'Year'] <- ry
NIBM[idx + 1,'Age'] <- 0
NIBM[idx + 1, 'Length_cm'] <- L1*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2) ## recalc error each time
NIBM[idx + 1, 'Weight'] <-  lw(NIBM[II,'Length_cm'])
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1)< P[1],1,0)
idx <- idx + 1
} ## end adding recruits
NIBM <- NIBM %>% filter(Age != -1) # To speed up remove all Age -1 animals at each time-step. idx is invalid now.
} ## end simu_year
# Compute the Ps -- this is the conditional probability step, based on raw...expectation?
P <- rep(1,a2); P[1] <- 0
for (Iage in 2:a2)
if (init_mat[Iage-1] < 1)
P[Iage] <- (init_mat[Iage]-init_mat[Iage-1])/(1-init_mat[Iage-1])
# Lognormal recruitment deviation module
recruit_dev = rnorm(simu_year,0,sigma_R)
recruit_dev_adj = (recruit_dev-0.5*sigma_R^2)
# RECy = round(R0_super*exp(recruit_dev_adj)) ## generate estimated recruit vector of length simu_year
RECy <- NULL
# RECy[1] <- R0_super
SSBy = NULL
SSBy[1] = SSB0
# with(NIBM, plot(Length_cm, Mature))
# Now loop forward [this is where mine comes in]
for(ry in 1:simu_year){ ## iterate sim years
# Alive <- !is.na(NIBM[,'Age']) & NIBM[,'Age'] > -1
# if(sum(is.na(NIBM[Alive,'Mature']))>0) stop(min(which(is.na(NIBM[Alive,'Mature'])))," is NA mature")
# cat("Alive",sum(Alive),"\n")
# Compute SSB
# Compute recruits here, this is how many we need to add later
if(ry == 1){
SSBy[ry] <- SSB0 ## SSB from last yr informs recruits
RECy[ry] <- round(BH_SR(SSB0) * exp(recruit_dev_adj[ry]))
}else{
SSBy[ry] <- sum(NIBM$Mature[NIBM$Year == (ry-1)] * NIBM$Weight[NIBM$Year == (ry-1)]) ## Mature of living x weight of living [survived]
RECy[ry] <- round(BH_SR(SSBy[ry]) * exp(recruit_dev_adj[ry]))
}
if(SSBy == 0)stop(ry," SSBY = 0 \n")
if(RECy[ry] < 1){ ## fail if less than one recruit
RECy[ry]=1 ## coerce to 1
print(paste0("!!! Recruitment Fail !!! year ",ry))
}
Ilast <- ifelse(ry == 1,1,min(which(NIBM$Year == (ry-1))))  ## where do individuals for prev year begin?
Ipnt <- ifelse(ry == 1,Ipnt0, nrow(subset(NIBM, Year == (ry-1)))) ## number of individuals
idx <- nrow(NIBM) ## last filled in row
for (II in Ilast:(Ilast+Ipnt-1)){ ## loop individuals for this year [given by Ipnt]
# if (Alive[II]){
MyAge <- NIBM[II,1] ## check age
# cat(NIBM[II,'UniqueID'],"\n") ## should not duplicate
NIBM[idx+1,'UniqueID'] <- NIBM[II,'UniqueID'] ## retain ID
NIBM[idx+1,'Year'] <- ry ## update year
# Died this year?
NIBM[idx+1,'Age'] <- ifelse(runif(1,0,1) > S, -1, ifelse(NIBM[II,'Age']+1 <= 15,NIBM[II,'Age']+1,15 )) ## Update dead, if not increase age by 1 year, coerce to 15 if older
# Now grow the animal and update its weight
NIBM[idx + 1, 'Length_cm'] <- NIBM[II, 'Length_cm'] +growth_incre(NIBM[II, 'Length_cm'])*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2)
NIBM[idx + 1, 'Weight'] <-  lw( NIBM[II,'Length_cm'])
# Mature this year?
if (is.na(NIBM[II,'Mature'])){NIBM[II,'Mature'] <- 0} ## replace NAs
if (NIBM[II,'Mature'] == 1){NIBM[idx + 1,'Mature'] <- 1} ## cannot un-mature
if(MyAge < 15 & NIBM[II,'Mature'] == 0){
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1) < P[MyAge+1],1,0)
} else if(MyAge >= 15 & NIBM[II,'Mature'] == 0){
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1) < P[MyAge],1,0)
}
idx <- idx + 1 ## bump down a row
# Add recruits starting from slots Ipnt + 1
# Ipnt <- Ipnt + 1 ## counting up individuals, new row for each
# } ## end if living
} ## end individuals
for(ir in 1:RECy[ry]){ ## now add individuals
NIBM[idx + 1,'UniqueID'] <- max(NIBM$UniqueID) + 1 ## new id; DO FIRST OTHERWISE FILLS NA
NIBM[idx + 1,'Year'] <- ry
NIBM[idx + 1,'Age'] <- 0
NIBM[idx + 1, 'Length_cm'] <- L1*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2) ## recalc error each time
NIBM[idx + 1, 'Weight'] <-  lw(NIBM[II,'Length_cm'])
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1)< P[1],1,0)
idx <- idx + 1
} ## end adding recruits
NIBM <- NIBM %>% filter(Age != -1) # To speed up remove all Age -1 animals at each time-step. idx is invalid now.
} ## end simu_year
require(dplyr)
# with(NIBM, plot(Length_cm, Mature))
# Now loop forward [this is where mine comes in]
for(ry in 1:simu_year){ ## iterate sim years
# Alive <- !is.na(NIBM[,'Age']) & NIBM[,'Age'] > -1
# if(sum(is.na(NIBM[Alive,'Mature']))>0) stop(min(which(is.na(NIBM[Alive,'Mature'])))," is NA mature")
# cat("Alive",sum(Alive),"\n")
# Compute SSB
# Compute recruits here, this is how many we need to add later
if(ry == 1){
SSBy[ry] <- SSB0 ## SSB from last yr informs recruits
RECy[ry] <- round(BH_SR(SSB0) * exp(recruit_dev_adj[ry]))
}else{
SSBy[ry] <- sum(NIBM$Mature[NIBM$Year == (ry-1)] * NIBM$Weight[NIBM$Year == (ry-1)]) ## Mature of living x weight of living [survived]
RECy[ry] <- round(BH_SR(SSBy[ry]) * exp(recruit_dev_adj[ry]))
}
if(SSBy == 0)stop(ry," SSBY = 0 \n")
if(RECy[ry] < 1){ ## fail if less than one recruit
RECy[ry]=1 ## coerce to 1
print(paste0("!!! Recruitment Fail !!! year ",ry))
}
Ilast <- ifelse(ry == 1,1,min(which(NIBM$Year == (ry-1))))  ## where do individuals for prev year begin?
Ipnt <- ifelse(ry == 1,Ipnt0, nrow(subset(NIBM, Year == (ry-1)))) ## number of individuals
idx <- nrow(NIBM) ## last filled in row
for (II in Ilast:(Ilast+Ipnt-1)){ ## loop individuals for this year [given by Ipnt]
# if (Alive[II]){
MyAge <- NIBM[II,1] ## check age
# cat(NIBM[II,'UniqueID'],"\n") ## should not duplicate
NIBM[idx+1,'UniqueID'] <- NIBM[II,'UniqueID'] ## retain ID
NIBM[idx+1,'Year'] <- ry ## update year
# Died this year?
NIBM[idx+1,'Age'] <- ifelse(runif(1,0,1) > S, -1, ifelse(NIBM[II,'Age']+1 <= 15,NIBM[II,'Age']+1,15 )) ## Update dead, if not increase age by 1 year, coerce to 15 if older
# Now grow the animal and update its weight
NIBM[idx + 1, 'Length_cm'] <- NIBM[II, 'Length_cm'] +growth_incre(NIBM[II, 'Length_cm'])*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2)
NIBM[idx + 1, 'Weight'] <-  lw( NIBM[II,'Length_cm'])
# Mature this year?
if (is.na(NIBM[II,'Mature'])){NIBM[II,'Mature'] <- 0} ## replace NAs
if (NIBM[II,'Mature'] == 1){NIBM[idx + 1,'Mature'] <- 1} ## cannot un-mature
if(MyAge < 15 & NIBM[II,'Mature'] == 0){
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1) < P[MyAge+1],1,0)
} else if(MyAge >= 15 & NIBM[II,'Mature'] == 0){
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1) < P[MyAge],1,0)
}
idx <- idx + 1 ## bump down a row
# Add recruits starting from slots Ipnt + 1
# Ipnt <- Ipnt + 1 ## counting up individuals, new row for each
# } ## end if living
} ## end individuals
for(ir in 1:RECy[ry]){ ## now add individuals
NIBM[idx + 1,'UniqueID'] <- max(NIBM$UniqueID) + 1 ## new id; DO FIRST OTHERWISE FILLS NA
NIBM[idx + 1,'Year'] <- ry
NIBM[idx + 1,'Age'] <- 0
NIBM[idx + 1, 'Length_cm'] <- L1*exp(rnorm(1,0,growth_lognormal_SD)-growth_lognormal_SD^2/2) ## recalc error each time
NIBM[idx + 1, 'Weight'] <-  lw(NIBM[II,'Length_cm'])
NIBM[idx + 1,'Mature'] <- ifelse(runif(1,0,1)< P[1],1,0)
idx <- idx + 1
} ## end adding recruits
NIBM <- NIBM %>% filter(Age != -1) # To speed up remove all Age -1 animals at each time-step. idx is invalid now.
} ## end simu_year
warnings(
)
NIBM
